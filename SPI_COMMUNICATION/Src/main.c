/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "spi.h"
#include <string.h>

#define GPIOB_BASEADDR			0x40020400U
#define RCC_AHB1ENR_ADDR		(RCC_BASEADDR +  0x30U)
#define GPIOB_MODER_ADDR		(GPIOB_BASEADDR + 0x00U)
#define GPIOB_OSPEEDR_ADDR		(GPIOB_BASEADDR + 0x08U)
#define GPIOB_AFRH_ADDR			(GPIOB_BASEADDR + 0x24U)

void delay(void)
{
	for(uint32_t i = 0 ; i< 250000 ; i++);
}

void GPIO_Init(void)
{
	/*
	 * Alternate Function Mode : 5
	 * PB12 --> NSS
	 * PB13 --> SCK
	 * PB14 --> MISO
	 * PB15 --> MOSI
	 */
	volatile uint32_t *AHB1ENR = (volatile uint32_t *) RCC_AHB1ENR_ADDR;
	volatile uint32_t *GPIOB_MODER = (volatile uint32_t *) GPIOB_MODER_ADDR;
	volatile uint32_t *GPIOB_OSPEEDR = (volatile uint32_t *) GPIOB_OSPEEDR_ADDR;
	volatile uint32_t *GPIOB_AFRH = (volatile uint32_t *) GPIOB_AFRH_ADDR;

	// 1. Enable GPIOB Peripheral Clock
	*AHB1ENR &= ~( 1U << 1);	//Reset Bit
	*AHB1ENR |= ( 1U << 1);		//Set Bit


	// 2. Set Mode as Alternate function
	//PB12
	*GPIOB_MODER &= ~( 3U << 24); //Reset Bit
	*GPIOB_MODER |= ( 1U << 25); //Set Bit

	//PB13
	*GPIOB_MODER &= ~( 3U << 26); //Reset Bit
	*GPIOB_MODER |= ( 1U << 27); //Set Bit

	//PB14
	*GPIOB_MODER &= ~( 3U << 28); //Reset Bit
	*GPIOB_MODER |= ( 1U << 29); //Set Bit

	//PB15
	*GPIOB_MODER &= ~( 3U << 30); //Reset Bit
	*GPIOB_MODER |= ( 1U << 31); //Set Bit


	//3. Set Speed
	//PB12
	*GPIOB_OSPEEDR &= ~( 3U << 24); //Reset Bit
	*GPIOB_OSPEEDR |= ( 3U << 24); //Set Bit

	//PB13
	*GPIOB_OSPEEDR &= ~( 3U << 26); //Reset Bit
	*GPIOB_OSPEEDR |= ( 3U << 26); //Set Bit

	//PB14
	*GPIOB_OSPEEDR &= ~( 3U << 28); //Reset Bit
	*GPIOB_OSPEEDR |= ( 3U << 28); //Set Bit

	//PB15
	*GPIOB_OSPEEDR &= ~( 3U << 30); //Reset Bit
	*GPIOB_OSPEEDR |= ( 3U << 30); //Set Bit

	//4. Select AF Mode 5
	//PB12
	*GPIOB_AFRH &= ~( 15U << 16); //Reset Bit
	*GPIOB_AFRH |= ( 5U << 16); //Set Bit

	//PB13
	*GPIOB_AFRH &= ~( 15U << 20); //Reset Bit
	*GPIOB_AFRH |= ( 5U << 20); //Set Bit

	//PB14
	*GPIOB_AFRH &= ~( 15U << 24); //Reset Bit
	*GPIOB_AFRH |= ( 5U << 24); //Set Bit

	//PB15
	*GPIOB_AFRH &= ~( 15U << 28); //Reset Bit
	*GPIOB_AFRH |= ( 5U << 28); //Set Bit
}
int main(void)
{
	const char string[]= "Hello world";
	SPI_Handle_t SPI2Handle;
	GPIO_Init();

	SPI2_Init(SPI_DEVICE_MODE_MASTER,SPI_BUS_CONFIG_FD,SPI_SCLK_SPEED_DIV8, SPI_DFF_8BITS, SPI_CPOL_HIGH, SPI_CPHA_HIGH, SPI_SSM_EN);

	while(1)
	{
		SPI_EN();
		SPI2_Data_Send((uint8_t*)string,strlen(string));
		SPI_DI();
		delay();
	}

}



// ISR
void SPI2_IRQHandler(void)
{
    SPI2_IRQHandling(&SPI2Handle);
}
